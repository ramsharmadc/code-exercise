defmodule Lbbroker do
  @moduledoc """
  Generated by erl2ex (http://github.com/dazuma/erl2ex)
  From Erlang source: (Unknown source file)
  At: 2019-12-20 13:57:26

  """

  defmacrop erlconst_NBR_CLIENTS() do
    quote do
      10
    end
  end


  defmacrop erlconst_NBR_WORKERS() do
    quote do
      3
    end
  end


  def client_task() do
    {:ok, context} = :erlzmq.context()
    {:ok, client} = :erlzmq.socket(context, :req)
    :ok = :erlzmq.setsockopt(client, :identity, :erlang.pid_to_list(self()))
    :ok = :erlzmq.connect(client, 'ipc://frontend.ipc')
    :ok = :erlzmq.send(client, "HELLO")
    {:ok, reply} = :erlzmq.recv(client)
    :io.format('Client: ~s~n', [reply])
    :ok = :erlzmq.close(client)
    :ok = :erlzmq.term(context)
  end


  def worker_task() do
    {:ok, context} = :erlzmq.context()
    {:ok, worker} = :erlzmq.socket(context, :req)
    :ok = :erlzmq.setsockopt(worker, :identity, :erlang.pid_to_list(self()))
    :ok = :erlzmq.connect(worker, 'ipc://backend.ipc')
    :ok = :erlzmq.send(worker, "READY")
    worker_loop(worker)
    :ok = :erlzmq.close(worker)
    :ok = :erlzmq.term(context)
  end


  def worker_loop(worker) do
    {:ok, address} = :erlzmq.recv(worker)
    {:ok, <<>>} = :erlzmq.recv(worker)
    {:ok, request} = :erlzmq.recv(worker)
    :io.format('Worker: ~s~n', [request])
    :ok = :erlzmq.send(worker, address, [:sndmore])
    :ok = :erlzmq.send(worker, <<>>, [:sndmore])
    :ok = :erlzmq.send(worker, "OK")
    worker_loop(worker)
  end


  def main() do
    {:ok, context} = :erlzmq.context()
    {:ok, frontend} = :erlzmq.socket(context, [:router, {:active, true}])
    {:ok, backend} = :erlzmq.socket(context, [:router, {:active, true}])
    :ok = :erlzmq.bind(frontend, 'ipc://frontend.ipc')
    :ok = :erlzmq.bind(backend, 'ipc://backend.ipc')
    start_clients(erlconst_NBR_CLIENTS())
    start_workers(erlconst_NBR_WORKERS())
    workerQueue = :queue.new()
    lru_loop(erlconst_NBR_CLIENTS(), workerQueue, frontend, backend)
    :ok = :erlzmq.close(frontend)
    :ok = :erlzmq.close(backend)
    :ok = :erlzmq.term(context)
  end


  def start_clients(0) do
    :ok
  end

  def start_clients(n) when n > 0 do
    :erlang.spawn(fn -> client_task() end)
    start_clients(n - 1)
  end


  def start_workers(0) do
    :ok
  end

  def start_workers(n) when n > 0 do
    :erlang.spawn(fn -> worker_task() end)
    start_workers(n - 1)
  end


  def lru_loop(0, _, _, _) do
    :ok
  end

  def lru_loop(numClients, workerQueue, frontend, backend) when numClients > 0 do
    case(:queue.len(workerQueue)) do
      0 ->
        receive do
          {:zmq, ^backend, msg, _} ->
            lru_loop_backend(numClients, workerQueue, frontend, backend, msg)
        end
      _ ->
        receive do
          {:zmq, ^backend, msg, _} ->
            lru_loop_backend(numClients, workerQueue, frontend, backend, msg)
          {:zmq, ^frontend, msg, _} ->
            lru_loop_frontend(numClients, workerQueue, frontend, backend, msg)
        end
    end
  end


  def lru_loop_backend(numClients, workerQueue, frontend, backend, workerAddr) do
    newWorkerQueue = :queue.in(workerAddr, workerQueue)
    {:ok, <<>>} = active_recv(backend)
    case(active_recv(backend)) do
      {:ok, "READY"} ->
        lru_loop(numClients, newWorkerQueue, frontend, backend)
      {:ok, clientAddr} ->
        {:ok, <<>>} = active_recv(backend)
        {:ok, reply} = active_recv(backend)
        :erlzmq.send(frontend, clientAddr, [:sndmore])
        :erlzmq.send(frontend, <<>>, [:sndmore])
        :erlzmq.send(frontend, reply)
        lru_loop(numClients - 1, newWorkerQueue, frontend, backend)
    end
  end


  def lru_loop_frontend(numClients, workerQueue, frontend, backend, clientAddr) do
    {:ok, <<>>} = active_recv(frontend)
    {:ok, request} = active_recv(frontend)
    {{:value, workerAddr}, newWorkerQueue} = :queue.out(workerQueue)
    :ok = :erlzmq.send(backend, workerAddr, [:sndmore])
    :ok = :erlzmq.send(backend, <<>>, [:sndmore])
    :ok = :erlzmq.send(backend, clientAddr, [:sndmore])
    :ok = :erlzmq.send(backend, <<>>, [:sndmore])
    :ok = :erlzmq.send(backend, request)
    lru_loop(numClients, newWorkerQueue, frontend, backend)
  end


  def active_recv(socket) do
    receive do
      {:zmq, ^socket, msg, _flags} ->
        {:ok, msg}
    end
  end

end

Lbbroker.main()
