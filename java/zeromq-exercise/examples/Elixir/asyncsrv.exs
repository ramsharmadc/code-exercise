defmodule asyncsrv do
  @moduledoc """
  Generated by erl2ex (http://github.com/dazuma/erl2ex)
  From Erlang source: (Unknown source file)
  At: 2019-12-20 13:57:22

  """

  def client_task() do
    {:ok, ctx} = :erlzmq.context()
    {:ok, client} = :erlzmq.socket(ctx, :dealer)
    :ok = :erlzmq.setsockopt(client, :identity, :erlang.pid_to_list(self()))
    :ok = :erlzmq.connect(client, 'tcp://localhost:5570')
    client_loop(client, 0)
    :ok = :erlzmq.term(ctx)
  end


  def client_loop(client, requestNbr) do
    client_check_messages(client, 100, 10)
    msg = :erlang.list_to_binary(:io_lib.format('request #~b', [requestNbr]))
    :erlzmq.send(client, msg)
    client_loop(client, requestNbr + 1)
  end


  def client_check_messages(_client, 0, _pollDelay) do
    :ok
  end

  def client_check_messages(client, n, pollDelay) when n > 0 do
    case(:erlzmq.recv(client, [:noblock])) do
      {:ok, msg} ->
        :io.format('~s [~p]~n', [msg, self()])
      {:error, :eagain} ->
        :timer.sleep(pollDelay)
    end
    client_check_messages(client, n - 1, pollDelay)
  end


  def server_task() do
    {:ok, ctx} = :erlzmq.context()
    :random.seed(:erlang.now())
    {:ok, frontend} = :erlzmq.socket(ctx, [:router, {:active, true}])
    :ok = :erlzmq.bind(frontend, 'tcp://*:5570')
    {:ok, backend} = :erlzmq.socket(ctx, [:dealer, {:active, true}])
    :ok = :erlzmq.bind(backend, 'inproc://backend')
    start_server_workers(ctx, 5)
    :erlzmq_device.queue(frontend, backend)
    :ok = :erlzmq.term(ctx)
  end


  def start_server_workers(_ctx, 0) do
    :ok
  end

  def start_server_workers(ctx, n) when n > 0 do
    :erlang.spawn(fn -> server_worker(ctx) end)
    start_server_workers(ctx, n - 1)
  end


  def server_worker(ctx) do
    :random.seed(:erlang.now())
    {:ok, worker} = :erlzmq.socket(ctx, :dealer)
    :ok = :erlzmq.connect(worker, 'inproc://backend')
    server_worker_loop(worker)
  end


  def server_worker_loop(worker) do
    {:ok, address} = :erlzmq.recv(worker)
    {:ok, content} = :erlzmq.recv(worker)
    send_replies(worker, address, content, :random.uniform(4) - 1)
    server_worker_loop(worker)
  end


  def send_replies(_, _, _, 0) do
    :ok
  end

  def send_replies(worker, address, content, n) when n > 0 do
    :timer.sleep(:random.uniform(1000))
    :ok = :erlzmq.send(worker, address, [:sndmore])
    :ok = :erlzmq.send(worker, content)
    send_replies(worker, address, content, n - 1)
  end


  def main(_) do
    :erlang.spawn(fn -> client_task() end)
    :erlang.spawn(fn -> client_task() end)
    :erlang.spawn(fn -> client_task() end)
    :erlang.spawn(fn -> server_task() end)
    :timer.sleep(5000)
  end

end
